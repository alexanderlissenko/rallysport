#version 420
//http://ephenationopengl.blogspot.se/2012/01/setting-up-deferred-shader.html
//http://ogldev.atspace.co.uk/www/tutorial36/tutorial36.html
precision mediump float;
in vec2 position;             // The world position
out vec4 fragColor;           // layout(location = 0)


uniform sampler2D diffuseTex; // The color information
uniform sampler2D posTex;     // World position
uniform sampler2D normalTex;  // Normals
uniform sampler2D depthTex;  // Depth
uniform sampler2DShadow shadowMapTex; 
uniform vec3 camera;          // The coordinate of the camera
uniform vec3 lightPos;
uniform vec3 lightDirection;
uniform float lightWidht;
uniform vec2 screenSize;

uniform float lightType;
uniform vec3 lightColor;
uniform float lightRadius;
uniform mat4 lightMatrix;
uniform mat4 modelViewMatrix;

uniform mat4 projectionMatrix;
uniform vec4 projectParam;
uniform vec3 scene_ambient_light = vec3(0.3,0.3,0.3);
uniform vec3 scene_light = vec3(0.6,0.6,0.6);

//// lighting function
vec3 calculateDiffuse(vec3 diffuseLight, vec3 materialDiffuse, vec3 normal, vec3 directionToLight)
{
	return diffuseLight *materialDiffuse* clamp(dot(normal,directionToLight),0,1);
}
vec3 calculateSpecular(vec3 specularLight, vec3 materialSpecular, float materialShininess, vec3 normal, vec3 directionToLight, vec3 directionFromEye)
{
	vec3 h = normalize(directionToLight - directionFromEye);
	float normalizeFactor = ((materialShininess+2.0)/8.0);
	return specularLight * materialSpecular* pow(max(0,dot(h,normal)), materialShininess)*normalizeFactor;
	}
vec3 calculateFresnel(vec3 materialSpecular, vec3 normal, vec3 directionFromEye) 
{
	return materialSpecular + (vec3(1.0)-materialSpecular)*pow(clamp(1.0+dot(directionFromEye,normal),0.0,1.0),5.0);
}
vec3 reconstructPosition(float p_depth, vec2 p_ndc, vec4 p_projParams)
{ 
    float depth = p_depth * 2.0f - 1.0f;
    float viewDepth = p_projParams.w / (depth - p_projParams.z);

    return vec3((p_ndc * viewDepth) / p_projParams.xy, viewDepth);
}
////

void main(void)
{
	vec4 light = vec4(lightPos,1.0);
	vec4 specularGlare = vec4(1.0,1.0,1.0,1.0);
	
   // Load data, stored in textures, from the first stage rendering.
   vec4 diffuse = texture2D(diffuseTex, position.xy);
   //vec3 worldPos = texture2D(posTex, position.xy).xyz;
   vec4 normal = texture2D(normalTex, position.xy);
   vec4 depth = texture2D(depthTex, position.xy);
   
   vec4 screen = vec4((position.xy*2)-1, (depth.x*2)-1, 1.0);
   vec4 worldPosUnHo = inverse(modelViewMatrix)*projectionMatrix * screen;
   vec3 worldPos = worldPosUnHo.xyz/worldPosUnHo.w;//reconstructPosition(depth,position.xy,projectParam);//
   //Constants
   vec3 ambient;
   if(diffuse.xyz != vec3(0.0))
   {
   ambient = diffuse.xyz * vec3(0.4);
   }
   else
   {
	ambient = vec3(0.1);
   }
   vec3 specular = vec3(0.5);
   float material_shininess = 5.0;
   
   vec3 directionToLight = normalize(lightPos-worldPos);
   vec3 directionFromEye = normalize(worldPos-camera);
   vec3 fresnelSpecular = calculateFresnel(specular,normal.xyz, directionFromEye);
   vec3 shading;
   //Calculate Lighting
   if(lightType == 0)
   {
   vec4 shadowMapCoord = lightMatrix *modelViewMatrix* vec4( worldPos,1);
   //shadowMapCoord.xyz *= vec3(0.5,0.5,0.5);
   //shadowMapCoord.xyz += shadowMapCoord.w * vec3(0.5,0.5,0.5);
   float visibility = textureProj(shadowMapTex, shadowMapCoord);

   
		shading = ambient*scene_ambient_light
				+ (calculateSpecular(scene_light, fresnelSpecular,material_shininess,normal.xyz,directionToLight,directionFromEye)
				+ calculateDiffuse(scene_light,diffuse.xyz,normal.xyz,directionToLight))*visibility;
					
   }
   if(lightType == 1.0)
   {
		float cutoff = 0.0005;
		vec3 lightVector = lightPos - worldPos.xyz;
		if(length(lightVector) < lightRadius)
		{
			float denom = (length(lightVector)/lightRadius)+1;
			float atten_factor = 1/(denom*denom);
			atten_factor = (atten_factor - cutoff) / (1-cutoff);
		
			atten_factor = max(atten_factor, 0);
			//float atten_factor = clamp(1/(1+((2/lightRadius)*(length(lightVector)))+(1/(pow(lightRadius,2))*pow(length(lightVector),2))),0.0,1.0);//clamp(1.0 - pow((length(lightVector)/lightRadius),4),0.0,1.0); 
		
			shading = (ambient*lightColor
					+ calculateSpecular(lightColor*scene_light, fresnelSpecular,material_shininess,normal.xyz,directionToLight,directionFromEye)
					+ calculateDiffuse(lightColor*scene_light,diffuse.xyz,normal.xyz,directionToLight))*atten_factor;//(vec4(lightColor,1)*atten_factor;//diffuse;
		}
		else
		{
			shading = vec3(0.0);
		}
   }
   if(lightType == 2.0)
   {
		float sDL = dot(lightDirection,-directionToLight);
		
		if(sDL > lightWidht)
		{	
			vec3 lightVector = lightPos - worldPos.xyz;
			if(length(lightVector) < lightRadius)
			{
				float cutoff = 0.0005;
				float denom = (length(lightVector)/lightRadius)+1;
				float atten_factor = 1/(denom*denom);
				atten_factor = (atten_factor - cutoff) / (1-cutoff);
				atten_factor = max(atten_factor, 0);
			 
				shading = (ambient*lightColor 	
						+ calculateSpecular(lightColor*scene_light, fresnelSpecular,material_shininess*4,normal.xyz,directionToLight,directionFromEye)
						+ calculateDiffuse(lightColor*scene_light,diffuse.xyz,normal.xyz,directionToLight))*atten_factor;
					 
			}
			else
			{
				shading = vec3(0.0);
			}
		}
		else
		{
			shading = vec3(0.0);
		}
   }
   

	fragColor = vec4(shading,1.0);


// Some debug features. Enable any of them to get a visual representation
// of an internal buffer.
// fragColor = vec4(shadowMapCoord.z/shadowMapCoord.w);
// fragColor = (normal+1)/2;
// fragColor = diffuse;
// fragColor = vec4(visibility);
// fragColor = vec4(depth.x);
// fragColor = vec4(worldPos.xyz,1); // Scaling may be needed to range [0,1]
// fragColor = light*vec4(1,1,1,1);
}




