#version 420

precision mediump float;
uniform sampler2D firstTexture;
uniform sampler2D normalTexture;
uniform vec3 diffuse;
uniform float shininess;
uniform mat4 modelMatrix;
in vec3 fragmentNormal;
in vec2 fragmentTexCoord;
in vec4 positionOut;
in vec4 prevPositionOut;       // The model coordinate, as given by the vertex shader
out vec4 diffuseOutput; // layout(location = 0)
out vec4 normOutput;    // layout(location = 2)
out vec2 velOutput;
//out vec4 blendOutput;   // layout(location = 3)
void main(void)
{
   vec3 c1 = cross(fragmentNormal, vec3(0.0,0.0,1.0));
   vec3 c2 = cross(fragmentNormal, vec3(0.0,1.0,0.0));
   vec3 tangent;
   if(length(c1)>length(c2))
   {
	tangent = c1;
   }	
   else
   {
	tangent = c2;
   }
   tangent = normalize(tangent);  //normalize(modelMatrix[0].xyz);
   vec3 binormal = normalize(cross(fragmentNormal,tangent));
   mat3 tangentToWorld = mat3(tangent.x,binormal.x,fragmentNormal.x,
							  tangent.y,binormal.y,fragmentNormal.y,
							  tangent.z,binormal.z,fragmentNormal.z);
   float shininessOut = shininess/1000;
   vec4 normTexture =texture(normalTexture, fragmentTexCoord); 
   vec3 normMap = (normTexture.xyz*2-1)*tangentToWorld;
   if (normTexture.xyz == vec3(0.0))
		normMap = fragmentNormal;
		
   
   vec4 clr = texture(firstTexture, fragmentTexCoord);
   
   if (clr.xyz == vec3(0.0))
		clr = vec4(diffuse*vec3(2),1);

   //float alpha = clr.a;
   //if (alpha < 0.1)
   //    discard;   // Optimization that will not change the depth buffer
   //blendOutput.rgb = clr.rgb * clr.a; // Pre multiplied alpha
   //blendOutput.a = clr.a;
   
   diffuseOutput = clr;
   normOutput=vec4(normMap,shininessOut);
   vec2 a = vec2(positionOut.xy/positionOut.w);
   vec2 b = vec2(prevPositionOut.xy/prevPositionOut.w);
   velOutput = (a-b)*0.5+0.5;
   velOutput = pow(velOutput, vec2(3.0));
}